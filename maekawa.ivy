#lang ivy1.7

type site
type time

# ASK ODED
# upon changing deliver from relations to derived, and adding deliver(message, site, site, time),
# all worked despite not working before. This should not be a semantic change.

module zeroed_total_order(t) = {
    relation (X:t < Y:t)
    relation (X:t <= Y:t)
    individual zero : t
    axiom [antireflexivity] ~(X:t < X)
    axiom [antisymmetry] ~(X:t < Y & Y < X)
    axiom [transitivity] X:t < Y & Y < Z -> X < Z
    axiom [totallity] X:t < Y | Y < X | X = Y
    axiom [related] X:t <= Y <-> X < Y | X = Y
    axiom [nonnegativity] zero <= X:t
}

instantiate zeroed_total_order(time)

individual site1 : site
individual site2 : site
# axiom site1 ~= site2

# network messages
relation deliver_request(S:site, R:site, T:time)
relation deliver_grant(S:site, R:site, T:time)
relation deliver_failed(S:site, R:site, T:time)
relation deliver_inquire(S:site, R:site, T:time)
relation deliver_yield(S:site, R:site, T:time)
relation deliver_release(S:site, R:site, T:time)

relation received_request_at(R:site, S:site, T:time)
relation sent_grant_at(R:site, S:site, T:time)

derived received_request(R:site, S:site) = exists T. received_request_at(R, S, T)
derived sent_grant(R:site, S:site) = exists T. sent_grant_at(R, S, T)

derived deliver_grant_(R:site, S:site) = exists T. deliver_grant(R, S, T)
derived deliver_yield_(K:site, R:site) = exists T. deliver_yield(K, R, T)
derived deliver_release_(S:site, R:site) = exists T. deliver_release(S, R, T)

relation sent_yield(K:site, R:site)

relation received_grant(S:site, R:site)
relation received_failed(S:site, R:site)

relation invoke(S:site)
relation critical(S:site)

individual now : time

action changetime = {
    local n : time {
	assume now < n;
	now := n;
    }
}

after init {
    deliver_request(S, R, T) := false;
    deliver_grant(S, R, T) := false;
    deliver_failed(S, R, T) := false;
    deliver_inquire(S, R, T) := false;
    deliver_yield(S, R, T) := false;
    deliver_release(S, R, T) := false;
    received_request_at(R, S, T) := false;
    sent_grant_at(R, S, T) := false;
    received_grant(S, R) := false;
    received_failed(S, R) := false;
    sent_yield(K, R) := false;
    invoke(S) := false;
    critical(S) := false;
    now := zero;
}

action minimizes_messages(r:site, t:time) returns (z:bool) = {
    z := true;
    if exists S:site, T:time. deliver_request(S, r, T) & T < t {
	z := false;
    };
    if exists S:site, T:time. deliver_grant(S, r, T) & T < t {
	z := false;
    };
    if exists S:site, T:time. deliver_inquire(S, r, T) & T < t {
	z := false;
    };
    if exists S:site, T:time. deliver_failed(S, r, T) & T < t {
	z := false;
    };
    if exists S:site, T:time. deliver_yield(S, r, T) & T < t {
	z := false;
    };
    if exists S:site, T:time. deliver_release(S, r, T) & T < t {
	z := false;
    };
    
}

# called asynchronously when s tries to hold the mutex
action initiate_request(s:site) = {
    require ~invoke(s);
    call changetime;
    invoke(s) := true;
    deliver_request(s, R, now) := true;
}


# called asynchronously when a request message is sent from s to r
action handle_request(s:site, r:site, t:time) = {
    require deliver_request(s, r, t) & minimizes_messages(r, t);
    deliver_request(s, r, t) := false;
    call changetime;
    if some t0:time, k:site. sent_grant_at(r, k, t0) {
	if t0 <= t {
	    deliver_failed(r, s, now) := true;
	} else {
	    deliver_inquire(r, k, now) := true;
	};
	received_request_at(r, s, t) := true;
    } else {
	deliver_grant(r, s, now) := true;
	sent_grant_at(r, s, t) := true;
    };
}

# called asynchronously when a grant message is sent from r to s
action handle_grant(r:site, s:site, t:time) = {
    require deliver_grant(r, s, t) & minimizes_messages(s, t);
    deliver_grant(r, s, t) := false;
    call changetime;
    received_grant(s, r) := true;
    received_failed(s, r) := false; # if received a grant, previous failed is irrelevant
    sent_yield(s, r) := false;
}


# called asynchronously when a failed message is sent from r to s
action handle_failed(r:site, s:site, t:time) = {
    require deliver_failed(r, s, t) & minimizes_messages(s, t);
    deliver_failed(r, s, t) := false;
    call changetime;
    received_failed(s, r) := true;
    # fails accumulate! MAYBE should cancel failed upon grant?
}

# called asynchronously when an inquire message is sent from r to k
action handle_inquire(r:site, k:site, t:time) = {
    require deliver_inquire(r, k, t) & minimizes_messages(k, t);
    deliver_inquire(r, k, t) := false;
    call changetime;
    if (exists O:site. received_failed(k, O) | sent_yield(k, O)) & received_grant(k, r) { # don't send yield if not received grant
	deliver_yield(k, r, now) := true;
	sent_yield(k, r) := true;
	received_grant(k, r) := false;
    };
}

# called asynchronously when a yield message is sent from k to r
action handle_yield(k:site, r:site, t:time) = {
    require deliver_yield(k, r, t) & minimizes_messages(r, t);
    deliver_yield(k, r, t) := false;
    call changetime;
    if some s0:site, t0:time. received_request_at(r, s0, t0) minimizing t0 {
	received_request_at(r, s0, t0) := false;
	sent_grant_at(r, s0, t0) := true;
	deliver_grant(r, s0, now) := true;
    };
    if some t1:time. sent_grant_at(r, k, t1) {
	received_request_at(r, k, t1) := true;
	sent_grant_at(r, k, t1) := false;
    };
}

# called asynchronously when a release message is sent from s to r
action handle_release(s:site, r:site, t:time) = {
    require deliver_release(s, r, t) & minimizes_messages(r, t);
    deliver_release(s, r, t) := false;
    call changetime;
    sent_grant_at(r, s, T) := false;
    if some s0:site, t0:time. received_request_at(r, s0, t0) minimizing t0 {
	received_request_at(r, s0, t0) := false;
	deliver_grant(r, s0, now) := true;
	sent_grant_at(r, s0, now) := true;
    };
}    

action enter_critical_section(s:site) = {
    require invoke(s) & forall R. received_grant(s, R);
    call changetime;
    critical(s) := true;
}

action exit_critical_section(s:site) = {
    require critical(s);
    call changetime;
    critical(s) := false;
    invoke(s) := false;
    deliver_release(s, R, now) := true;
    received_grant(s, R) := false;
}

export initiate_request
export handle_request
export handle_grant
export handle_failed
export handle_inquire
export handle_yield
export handle_release
export enter_critical_section
export exit_critical_section

##################
#                #
#   INVARIANTS   #
#                #
##################

# CRITICAL SECTION
invariant critical(S1) & critical(S2) -> S1 = S2 # MUTUAL EXCLUSION: no more than one site holds the mutex
invariant critical(S) -> received_grant(S, R) # BASIC INVARIANT (QUORUM): holding the mutex requires grants from all sites
invariant ~(critical(S) & deliver_yield(S, R, T))
invariant ~(critical(S) & deliver_failed(R, S, T))
invariant ~(critical(S) & received_failed(S, R))
invariant ~(critical(S) & sent_yield(S, R))
invariant ~(critical(S) & received_request_at(R, S, T)) # a site in the critical section must have positive answers for all requests
invariant ~(critical(S) & deliver_request(S, R, T)) # a site in the critical section must have positive answers for all requests

# TIMING: messages cannot be sent after current time
invariant deliver_request(S, R, T) -> T <= now
invariant deliver_grant(S, R, T) -> T <= now
invariant deliver_inquire(R, K, T) -> T <= now
invariant deliver_yield(K, R, T) -> T <= now
invariant deliver_failed(R, S, T) -> T <= now
invariant deliver_release(R, S, T) -> T <= now
invariant received_request_at(R, S, T) -> T <= now
invariant sent_grant_at(R, S, T) -> T <= now

# TIMING: a site cannot send more than one message at a moment
invariant deliver_request(S, R, T1) & deliver_grant(S, R, T2) -> T1 ~= T2
invariant deliver_request(S, R, T1) & deliver_inquire(S, R, T2) -> T1 ~= T2
invariant deliver_request(S, R, T1) & deliver_yield(S, R, T2) -> T1 ~= T2
invariant deliver_request(S, R, T1) & deliver_release(S, R, T2) -> T1 ~= T2
invariant deliver_request(S, R, T1) & deliver_failed(S, R, T2) -> T1 ~= T2
invariant deliver_grant(S, R, T1) & deliver_inquire(S, R, T2) -> T1 ~= T2
invariant deliver_grant(S, R, T1) & deliver_yield(S, R, T2) -> T1 ~= T2
invariant deliver_grant(S, R, T1) & deliver_failed(S, R, T2) -> T1 ~= T2
invariant deliver_grant(S, R, T1) & deliver_release(S, R, T2) -> T1 ~= T2
invariant deliver_failed(S, R, T1) & deliver_inquire(S, R, T2) -> T1 ~= T2
invariant deliver_failed(S, R, T1) & deliver_yield(S, R, T2) -> T1 ~= T2
invariant deliver_failed(S, R, T1) & deliver_release(S, R, T2) -> T1 ~= T2
invariant deliver_yield(S, R, T1) & deliver_release(S, R, T2) -> T1 ~= T2
invariant deliver_yield(S, R, T1) & deliver_inquire(S, R, T2) -> T1 ~= T2
invariant deliver_inquire(S, R, T1) & deliver_release(S, R, T2) -> T1 ~= T2

invariant deliver_failed(R, S, T1) -> (received_request(R, S) | sent_grant(R, S))
invariant ~(deliver_failed(R, S, T1) & deliver_release(S, R, T2))
invariant invoke(S) -> forall R. exists T. deliver_request(S, R, T) | received_request_at(R, S, T) | (sent_grant_at(R, S, T) & ~deliver_release_(S, R))
invariant critical(S) -> invoke(S) # if a site holds the mutex it tried to do so
invariant deliver_grant(R, S, T) -> invoke(S) # if a grant is sent to a site, it must have tried to hold the mutex
invariant deliver_request(S, R, T) -> invoke(S) # a site can send requests only upon trying to hold the mutex
invariant received_grant(S, R) -> invoke(S)
invariant received_failed(S, R) -> invoke(S)

invariant received_request_at(R, S, T1) -> invoke(S) | deliver_release_(S, R)
invariant received_request_at(R, S, T1) & deliver_release(S, R, T2) -> T1 < T2
invariant sent_grant_at(R, S, T1) -> invoke(S) | deliver_release_(S, R)
invariant sent_grant_at(R, S, T1) & deliver_release(S, R, T2) -> T1 < T2
invariant deliver_request(S, R, T1) & sent_grant_at(R, S, T2) -> deliver_release_(S, R) # demonstration
invariant deliver_request(S, R, T1) & sent_grant_at(R, S, T2) & deliver_release(S, R, T3) -> T2 < T3 & T3 < T1

invariant deliver_request(S, R, T1) & deliver_release(S, R, T2) -> T2 < T1
invariant deliver_release(S, R, T1) & sent_grant_at(R, S, T2) -> T2 < T1
invariant deliver_request(S, R, T1) & sent_grant_at(R, S, T2) -> T2 < T1 # cannot deliver request to a site that gave you a grant
invariant sent_grant_at(R, K, T1) & deliver_yield(K, R, T2) -> T1 < T2
invariant deliver_failed(R, S, T1) & deliver_grant(R, S, T2) -> T1 < T2
invariant received_request_at(R, S, T1) & deliver_release(S, R, T2) -> T2 < T1

invariant sent_grant_at(R, S1, T1) & sent_grant_at(R, S2, T2) -> S1 = S2 & T1 = T2 # can send a grant to 1 site only
invariant received_grant(S1, R) & received_grant(S2, R) -> S1 = S2 # can send a grant to 1 site only
invariant received_request_at(R, S, T1) & received_request_at(R, S, T2) -> T1 = T2
invariant deliver_request(S, R, T1) & deliver_request(S, R, T2) -> T1 = T2 # can send a request 1 time only
invariant deliver_grant(R, S1, T1) & deliver_grant(R, S2, T2) -> S1 = S2 & T1 = T2 # can send a grant 1 time only, to only 1 site
invariant deliver_failed(R, S, T1) & deliver_failed(R, S, T2) -> T1 = T2 # can send a failed 1 time only
invariant deliver_release(S, R, T1) & deliver_release(S, R, T2) -> T1 = T2
invariant deliver_yield(K, R, T1) & deliver_yield(K, R, T2) -> T1 = T2

invariant sent_grant_at(R, S, T1) & received_failed(S, R) -> deliver_grant_(R, S)
invariant sent_grant_at(R, S, T1) & deliver_failed(R, S, T2) -> deliver_grant_(R, S)


invariant received_grant(S, R) -> sent_grant(R, S) # if S received a grant from R, then R sent a grant
invariant deliver_grant(R, S, T1) -> sent_grant(R, S) # if a grant was not yet received, it is still recorded in R
invariant deliver_failed(R, S, T1) -> received_request(R, S) | sent_grant(R, S) # if a failed message was not yet received, S is still in R's queue
invariant deliver_release(S, R, T1) -> sent_grant(R, S)
invariant deliver_yield(K, R, T1) -> sent_grant(R, K)


invariant ~(deliver_release(S, R, T1) & deliver_grant(R, S, T2))
invariant ~(deliver_release(S, R, T1) & received_grant(S, R))
invariant ~(deliver_release(S, R, T1) & received_request_at(R, S, T2))
invariant ~(deliver_release(S, R, T2) & received_failed(S, R))
invariant ~(deliver_grant(R, S, T1) & received_grant(K, R)) # if K has a grant from R, R cannot send any more grants
invariant ~(deliver_grant(R, S, T1) & received_grant(S, R)) # cannot redeliver a grant
invariant ~(deliver_request(S, R, T1) & received_request_at(R, S, T2)) # cannot send a request while in some site's queue
invariant ~(deliver_request(S, R, T1) & deliver_grant(R, S, T2)) # a requesting site cannot be granted
invariant ~(deliver_request(S, R, T1) & received_failed(S, R))
invariant ~(deliver_request(S, R, T1) & received_grant(S, R)) # if S has received a grant from R, it cannot send another request
invariant ~(received_request_at(R, S, T1) & sent_grant_at(R, S, T2)) # sent grant is not contained in request queue
invariant ~(deliver_yield(S, R, T) & received_grant(S, R))
invariant ~(deliver_yield(S, R, T1) & deliver_grant(R, S, T2))
invariant ~(deliver_failed(R, S, T1) & received_grant(S, R))
invariant ~(sent_yield(S, R) & received_grant(S, R))
invariant ~(received_failed(S, R) & received_grant(S, R))
invariant ~(deliver_yield(K, R, T1) & deliver_release(K, R, T2))

##############################
# The problematic invariants #
##############################

###########################
# The invariant graveyard #
###########################

# invariant ~(deliver_yield(K, R, T1) & deliver_release(K, R, T2)) # *** illusive - truly depedent on quorums
# invariant deliver_yield(K, R, T1) -> sent_yield(K, R) | sent_grant(R, K)
# invariant sent_yield(K, R) & sent_grant(R, K) -> exists T. deliver_yield(K, R, T) | deliver_grant(R, K, T)
# invariant sent_yield(K, R) & sent_grant_at(R, K, T2) -> deliver_yield_(K, R) - wrong - maybe gentlize
# invariant deliver_yield(K, R, T1) & sent_grant(R, K) & deliver_release(K, R, T2) -> T1
# invariant ~(deliver_failed(R, S, T1) & sent_grant_at(R, S, T2)) - totally wrong
# invariant deliver_grant(R, S, T1) & sent_grant_at(R, S, T2) -> T2 < T1
