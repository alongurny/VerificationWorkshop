#lang ivy1.7

type site
type time

module zeroed_total_order(t) = {
    relation (X:t < Y:t)
    relation (X:t <= Y:t)
    individual zero : t
    axiom [antireflexivity] ~(X:t < X)
    axiom [antisymmetry] ~(X:t < Y & Y < X)
    axiom [transitivity] X:t < Y & Y < Z -> X < Z
    axiom [totallity] X:t < Y | Y < X | X = Y
    axiom [related] X:t <= Y <-> X < Y | X = Y
    axiom [nonnegativity] zero <= X:t
}

instantiate zeroed_total_order(time)

# network messages
relation deliver_request(S:site, R:site, T:time)
relation deliver_grant(S:site, R:site, T:time)
relation deliver_failed(S:site, R:site, T:time)
relation deliver_inquire(S:site, R:site, T:time)
relation deliver_yield(S:site, R:site, T:time)
relation deliver_release(S:site, R:site, T:time)

relation received_request_at(R:site, S:site, T:time)
relation sent_grant_at(R:site, S:site, T:time)

derived received_request(R:site, S:site) = exists T. received_request_at(R, S, T)
derived sent_grant(R:site, S:site) = exists T. sent_grant_at(R, S, T)

relation sent_yield(K:site, R:site)

relation received_grant(S:site, R:site)
relation received_failed(S:site, R:site)

relation invoke(S:site)
relation critical(S:site)

individual now : time

action changetime = {
    local n : time {
	assume now < n;
	now := n;
    }
}

after init {
    deliver_request(S, R, T) := false;
    deliver_grant(S, R, T) := false;
    deliver_failed(S, R, T) := false;
    deliver_inquire(S, R, T) := false;
    deliver_yield(S, R, T) := false;
    deliver_release(S, R, T) := false;
    received_request_at(R, S, T) := false;
    sent_grant_at(R, S, T) := false;
    received_grant(S, R) := false;
    received_failed(S, R) := false;
    sent_yield(K, R) := false;
    invoke(S) := false;
    critical(S) := false;
    now := zero;
}

# called asynchronously when s tries to hold the mutex
action initiate_request(s:site) = {
    require ~invoke(s);
    invoke(s) := true;
    deliver_request(s, R, now) := true;
}

# called asynchronously when a request message is sent from s to r
action handle_request(s:site, r:site, t:time) = {
    require deliver_request(s, r, t) & (deliver_request(s, r, T) -> t <= T);
    deliver_request(s, r, t) := false;
    call changetime;
    if some t0:time, k:site. sent_grant_at(r, k, t0) {
	if t0 <= t {
	    deliver_failed(r, s, now) := true;
	} else {
	    deliver_inquire(r, k, now) := true;
	};
	received_request_at(r, s, t) := true;
    } else {
	deliver_grant(r, s, now) := true;
	sent_grant_at(r, s, t) := true;
    };
}

# called asynchronously when a grant message is sent from r to s
action handle_grant(r:site, s:site, t:time) = {
    require deliver_grant(r, s, t) & (deliver_grant(r, s, T) -> t <= T);
    deliver_grant(r, s, t) := false;
    call changetime;
    received_grant(s, r) := true;
    received_failed(s, r) := false; # if received a grant, previous failed is irrelevant
    # sent_inquire(s, r) := false; # should check this
    # sent_yield(s, r) := false;
}


# called asynchronously when a failed message is sent from r to s
action handle_failed(r:site, s:site, t:time) = {
    require deliver_failed(r, s, t) & (deliver_failed(r, s, T) -> t <= T);
    deliver_failed(r, s, t) := false;
    call changetime;
    received_failed(s, r) := true;
    # fails accumulate! MAYBE should cancel failed upon grant?
}

# called asynchronously when an inquire message is sent from r to k
action handle_inquire(r:site, k:site, t:time) = {
    require deliver_inquire(r, k, t) & (deliver_inquire(r, k, T) -> t <= T);
    deliver_inquire(r, k, t) := false;
    call changetime;
    if exists O:site. received_failed(k, O) { # if received any fail or gave any yield
	deliver_yield(k, r, now) := true;
	sent_yield(k, r) := true;
    };
}

# called asynchronously when a yield message is sent from k to r
action handle_yield(k:site, r:site, t:time) = {
    require deliver_yield(k, r, t) & (deliver_yield(k, r, T) -> t <= T);
    deliver_yield(k, r, t) := false;
    call changetime;
    if some s0:site, t0:time. received_request_at(r, s0, t0) minimizing t0 {
	received_request_at(r, s0, t0) := false;
	sent_grant_at(r, k, t0) := true;
	deliver_grant(r, s0, now) := true;
    };
    if some t1:time. sent_grant_at(r, k, t1) {
	received_request_at(r, k, t1) := true;
	sent_grant_at(r, k, t1) := false;
    };
}

# called asynchronously when a release message is sent from s to r
action handle_release(s:site, r:site, t:time) = {
    require deliver_release(s, r, t) & (deliver_release(s, r, T) -> t <= T);
    deliver_release(s, r, t) := false;
    call changetime;
    sent_grant_at(r, s, T) := false;
    if some s0:site, t0:time. received_request_at(r, s0, t0) minimizing t0 {
	received_request_at(r, s0, t0) := false;
	deliver_grant(r, s0, now) := true;
    };
    received_failed(r, s) := false;
    sent_yield(r, s) := false;
}    

action enter_critical_section(s:site) = {
    require invoke(s) & forall R. received_grant(R, s);
    call changetime;
    critical(s) := true;
}

action exit_critical_section(s:site) = {
    require critical(s);
    call changetime;
    critical(s) := false;
    invoke(s) := false;
    deliver_release(s, R, now) := true;
    received_grant(s, R) := false;
#   received_failed(s, R) := false;
#   sent_grant_at(s, R, T) := false;
#   sent_yield(s, R) := false;
#   sent_inquire(s, R) := false;
}

export initiate_request
export handle_request
export handle_grant
export handle_failed
export handle_inquire
export handle_yield
export enter_critical_section
export exit_critical_section

##############
# invariants #
##############


invariant critical(S) -> invoke(S) # if a site holds the mutex it tried to do so
# the following invariant is wrong because after exiting critical section, received_grant(S, R) can still be true
# invariant received_grant(S, R) -> invoke(S)
# if a grant is sent to a site, it must have tried to hold the mutex

invariant deliver_grant(R, S, T) -> invoke(S) # if a grant is sent to a site, it must have tried to hold the mutex
invariant deliver_request(S, R, T) -> invoke(S) # a site can send requests only upon trying to hold the mutex
invariant received_request_at(R, S, T) -> invoke(S)

invariant deliver_request(S, R, T) -> T <= now
invariant deliver_grant(S, R, T) -> T <= now
invariant deliver_inquire(R, K, T) -> T <= now
invariant deliver_yield(K, R, T) -> T <= now
invariant deliver_failed(R, S, T) -> T <= now
invariant deliver_release(R, S, T) -> T <= now
invariant received_request_at(R, S, T) -> T <= now
invariant sent_grant_at(R, S, T) -> T <= now

invariant critical(S1) & critical(S2) -> S1 = S2 # mutual exclusion is kept
invariant critical(S) -> received_grant(S, R) # holding the mutex requires grants from all sites
invariant ~(received_request_at(R, S, T) & critical(S)) # a site in the critical section must have positive answers for all requests
invariant ~(deliver_request(S, R, T) & critical(S)) # a site in the critical section must have positive answers for all requests

invariant sent_grant_at(R, S1, T1) & sent_grant_at(R, S2, T2) -> S1 = S2 & T1 = T2 # can send a grant to 1 site only
invariant received_grant(S1, R) & received_grant(S2, R) -> S1 = S2 # can send a grant to 1 site only
invariant deliver_request(S, R, T1) & deliver_request(S, R, T2) -> T1 = T2 # can send a request 1 time only
invariant deliver_grant(R, S1, T1) & deliver_grant(R, S2, T2) -> S1 = S2 & T1 = T2 # can send a grant 1 time only, to only 1 site
# invariant deliver_inquire(R, S, T1) & deliver_inquire(R, S, T2) -> T1 = T2 # can send an inquire 1 time only
invariant deliver_yield(R, S, T1) & deliver_yield(R, S, T2) -> T1 = T2 # can send a yield 1 time only
invariant deliver_failed(R, S, T1) & deliver_failed(R, S, T2) -> T1 = T2 # can send a failed 1 time only
invariant received_request_at(R, S, T1) & received_request_at(R, S, T2) -> T1 = T2

invariant received_grant(S, R) -> sent_grant(R, S) # if S received a grant from R, then R sent a grant
invariant deliver_grant(R, S, T1) -> sent_grant(R, S) # if a grant was not yet received, it is still recorded in R
invariant deliver_yield(K, R, T1) -> sent_yield(K, R) # if a yield was not yet received, it is still recorded in K
invariant deliver_yield(K, R, T1) -> sent_grant(R, K) # if a yield was not yet received, R still grants K
invariant deliver_inquire(R, K, T1) -> sent_grant(R, K) # if R tries to inquire from K, it still grants K
invariant deliver_inquire(R, K, T1) & sent_grant_at(R, K, T2) -> T2 < T1 # deliver inquire comes after sent_grant_at
invariant deliver_failed(R, S, T1) -> received_request(R, S) # if a failed message was not yet received, S is still in R's queue

    

invariant ~(received_grant(K, R) & deliver_grant(R, S, T2)) # if K has a grant from R, R cannot send any more grants
invariant ~(received_grant(S, R) & deliver_request(S, R, T2)) # if S has received a grant from R, it cannot send another request
invariant ~(received_request_at(R, S, T1) & sent_grant_at(R, S, T2)) # sent grant is not contained in request queue
invariant ~(deliver_grant(R, S, T1) & received_grant(S, R)) # cannot redeliver a grant
invariant ~(deliver_request(S, R, T1) & received_request_at(R, S, T2)) # cannot send a request while in some site's queue
invariant ~(deliver_request(S, R, T1) & received_request_at(R, S, T2)) # cannot deliver request if already received
invariant ~(deliver_request(S, R, T1) & deliver_grant(R, S, T2)) # a requesting site cannot be granted
invariant ~(deliver_request(S, R, T1) & sent_grant_at(R, S, T2)) # cannot deliver request to a site that gave you a grant
# invariant ~(deliver_yield(K, R, T1) & deliver_inquire(R, K, T2)) wrong
invariant ~(deliver_inquire(R, K, T1) & sent_yield(K, R)) # cannot inquire from K if K already sent a yield



    
invariant invoke(S) -> forall R. exists T. deliver_request(S, R, T) | received_request_at(R, S, T) | sent_grant_at(R, S, T) 
