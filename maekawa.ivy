#lang ivy1.7

type site
type time

module zeroed_total_order(t) = {
    relation (X:t < Y:t)
    relation (X:t <= Y:t)
    individual zero : t
    axiom [antireflexivity] ~(X:t < X)
    axiom [antisymmetry] ~(X:t < Y & Y < X)
    axiom [transitivity] X:t < Y & Y < Z -> X < Z
    axiom [totallity] X:t < Y | Y < X | X = Y
    axiom [related] X:t <= Y <-> X < Y | X = Y
    axiom [nonnegativity] zero <= X:t
}

instantiate zeroed_total_order(time)

# network messages
relation deliver_request(S:site, R:site, T:time)
relation deliver_grant(S:site, R:site, T:time)
relation deliver_failed(S:site, R:site, T:time)
relation deliver_inquire(S:site, R:site, T:time)
relation deliver_yield(S:site, R:site, T:time)
relation deliver_release(S:site, R:site, T:time)

relation received_request_at(R:site, S:site, T:time)
relation sent_grant_at(R:site, S:site, T:time)

relation received_grant_at(S:site, R:site, T:time)
relation received_failed_at(S:site, R:site, T:time)

derived sent_grant(S:site, R:site) = exists T. sent_grant_at(S, R, T)
derived received_grant(S:site, R:site) = exists T. received_grant_at(S, R, T)

relation invoke(S:site)
relation critical(S:site)

individual now : time

action changetime = {
    local n : time {
	assume now < n;
	now := n;
    }
}

after init {
    deliver_request(S, R, T) := false;
    deliver_grant(S, R, T) := false;
    deliver_failed(S, R, T) := false;
    deliver_inquire(S, R, T) := false;
    deliver_yield(S, R, T) := false;
    deliver_release(S, R, T) := false;

    received_request_at(S, R, T) := false;
    sent_grant_at(R, S, T) := false;
    received_grant_at(S, R, T) := false;
    received_failed_at(S, R, T) := false;

    invoke(S) := false;
    critical(S) := false;
    
    now := zero;
}

action initiate_request(s:site) = {
    require ~invoke(s);
    invoke(s) := true;
    deliver_request(s, R, now) := true;
}

action handle_request(s:site, r:site, t:time) = {
    require deliver_request(s, r, t);
    deliver_request(s, r, t) := false;
    call changetime;
    if some t0:time, k:site. sent_grant_at(r, k, t0) {
	if t0 <= t {
	    deliver_failed(r, s, now) := true;
	} else {
	    deliver_inquire(r, k, now) := true;
	};
	received_request_at(r, s, t) := true; # add to queue anyway - not sure if this is correct.
    } else {
	deliver_grant(r, s, now) := true;
	sent_grant_at(r, s, now) := true;
    };
}

action handle_grant(r:site, s:site, t:time) = {
    require deliver_grant(r, s, t);
    deliver_grant(r, s, t) := false;
    call changetime;
    received_grant_at(s, r, t) := true;
}

action handle_failed(r:site, s:site, t:time) = {
    require deliver_failed(r, s, t);
    deliver_failed(r, s, t) := false;
    call changetime;
    received_failed_at(s, r, t) := true;
}

action enter_critical_section(s:site) = {
    require invoke(s) & forall R. received_grant(R, s);
    call changetime;
    critical(s) := true;
}

action exit_critical_section(s:site) = {
    require critical(s);
    call changetime;
    critical(s) := false;
    invoke(s) := false;
    deliver_release(s, R, now) := true;
    received_grant_at(s, R, T) := false;
    received_failed_at(s, R, T) := false;
}

export initiate_request
export handle_request
export handle_grant
export handle_failed
export enter_critical_section
export exit_critical_section

invariant sent_grant_at(R, S1, T1) & sent_grant_at(R, S2, T2) -> S1 = S2 & T1 = T2 # can send a grant to 1 site only
invariant received_grant_at(S1, R, T1) & received_grant_at(S2, R, T2) -> S1 = S2 & T1 = T2 # can send a grant to 1 site only
invariant critical(S1) & critical(S2) -> S1 = S2 # mutual exclusion is kept
invariant critical(S) -> forall R. received_grant(S, R) # holding the mutex requires grants from all sites
invariant deliver_grant(R, S, T) -> sent_grant_at(R, S, T) # if a grant was not yet received, it is still recorded in R
invariant ~(received_grant(K, R) & deliver_grant(R, S, T)) # if K has a grant from R, R cannot send any more grants
invariant ~(deliver_request(S, R, T) & critical(S)) # a site in the critical section must have positive answers for all requests
invariant ~(deliver_request(S, R, T1) & deliver_grant(R, S, T2)) # a requesting site cannot be granted
invariant deliver_request(S, R, T) -> invoke(S) # a site can send requests only upon trying to hold the mutex
invariant critical(S) -> invoke(S) # if a site holds the mutex it tried to do so
invariant deliver_request(S, R, T1) & deliver_request(S, R, T2) -> T1 = T2 # a site can only send one request to another site
invariant received_grant_at(S, R, T) -> sent_grant_at(R, S, T) # if S received a grant from R, then R sent a grant
invariant ~(deliver_grant(R, S, T1) & received_grant_at(S, R, T2)) # cannot redeliver a grant
invariant received_grant_at(S, R, T) -> invoke(S) # if a grant is sent to a site, it must have tried to hold the mutex
invariant deliver_grant(R, S, T) -> invoke(S) # if a grant is sent to a site, it must have tried to hold the mutex
invariant ~(received_grant_at(S, R, T1) & deliver_request(S, R, T2)) # if S has received a grant from R, it cannot send another request
