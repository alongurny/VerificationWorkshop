#lang ivy1.7

type site
type time

module total_order(t) = {
    relation (X:t < Y:t)
    relation (X:t <= Y:t)
    individual zero : t
    axiom [antireflexivity] ~(X:t < X)
    axiom [antisymmetry] ~(X:t < Y & Y < X)
    axiom [transitivity] X:t < Y & Y < Z -> X < Z
    axiom [totallity] X:t < Y | Y < X | X = Y
    axiom [related] X:t <= Y <-> X < Y | X = Y
    axiom [nonnegativity] zero <= X:t
}

instantiate total_order(time)
# instantiate total_order(site)

relation quorum(S:site, R:site)
relation queue(T:time, S:site, R:site)
relation request(T:time, S:site, R:site)
relation grant(T:time, S:site, R:site)
relation grant_(S:site, R:site)
relation inquire(S:site, R:site)
relation failed(S:site, R:site)
relation yield(S:site, R:site)
relation release(S:site, R:site)
relation critical(S:site)

individual now : time

individual s1 : site
individual s2 : site
individual s3 : site

axiom s1 ~= s2 & s1 ~= s3 & s2 ~= s3

action changetime = {
    local n : time {
	n := *;
	assume now < n;
	now := n;
    }
}

after init {
    request(T, S, R) := false;
    grant(T, S, R) := false;
    grant_(S, R) := false;
    inquire(S, R) := false;
    yield(S, R) := false;
    failed(S, R) := false;
    release(S, R) := false;
    critical(S) := false;
    now := zero;
}

action handle_request(ts:time, sender:site, receiver:site) = {
    require request(ts, sender, receiver);
    call changetime;
    if exists T:time, K:site. grant(T, receiver, K) {
	if T < ts {
	    failed(receiver, sender) := true;
	} else {
	    inquire(receiver, sender) := true;
	};
	if ~exists T1:time. queue(T1, sender, receiver) { # not sure what the algorithm di
	    queue(ts, sender, receiver) := true;
	};
    } else {
	grant(ts, receiver, sender) := true;
	grant_(receiver, sender) := true;
    };
    request(ts, sender, receiver) := false;
}

action handle_inquire(sender:site, receiver:site) = {
    require inquire(sender, receiver);
    call changetime;
    inquire(sender, receiver) := false;
    if exists Other:site. sender ~= Other & failed(Other, receiver) {
	local other:site {
	    assume sender ~= other & failed(other, receiver);
	    yield(receiver, sender) := true;
	    failed(other, receiver) := false;
	};
    } else if exists Other:site. sender ~= Other & yield(receiver, Other) {
	if ~grant_(Other, receiver) {
	    yield(receiver, sender) := true;
	};
    };
}

action handle_yield(sender:site, receiver:site) = {
    require yield(sender, receiver);
    call changetime;
    if exists T:time, S:site. queue(T, S, receiver) { # if the queue is not empty
	local max_t:time, max_s:site { # find the maximum
	    max_t := *;
	    max_s := *;
	    assume forall T0:time, S0:site. queue(T0, S0, receiver) -> T <= T0;
	    queue(T, S, receiver) := false; # push the maximum out of the queue
	    grant(T, receiver, S) := true; # give the maximum a grant
	    grant_(receiver, S) := true;
	};
    };
    if grant_(sender, receiver) { # find the grant that was given and cancel and queue it
	local t:time {
	    t := *;
	    assume grant(t, sender, receiver);
	    grant(t, sender, receiver) := false;
	    grant_(sender, receiver) := false;
	    queue(T, sender, receiver) := true;
	};
    } else {
#	assert false; ask oded
    };
    yield(sender, receiver) := false;
}

action handle_release(sender:site, receiver:site) = {
    require release(sender, receiver);
    call changetime;
    release(sender, receiver) := false;
    queue(T:time, sender, receiver) := false;
    if exists T:time, S:site. queue(T, S, receiver) {
	local t:time, s:site {
	    t := *;
	    s := *;
	    assume queue(t, s, receiver);
	    assume queue(T0, S0, receiver) -> t <= T0; # t has top priority
	    grant(t, receiver, s) := true;
	    grant_(receiver, s) := true;
	};
    };
}

action enter_critical_section(s:site) = {
    require forall R:site. s ~= R -> grant_(R, s);
    critical(s) := true;
}

action exit_critical_section(s:site) = {
    require critical(s);
    critical(s) := false;
    release(s, X) := ~(s = X);
}

export handle_request
export handle_inquire
export handle_yield
export handle_release
export enter_critical_section
export exit_critical_section

invariant grant(T1, S, R1) & grant(T2, S, R2) -> T1 = T2 & R1 = R2  # every site can give only one grant
invariant grant_(S, R1) & grant_(S, R2) -> R1 = R2
invariant yield(K, J) -> inquire(J, K) # if someone sent a yield msg he must have recieved an inquire msg
invariant inquire(J, K) -> grant_(J, K) # if someone sent an inquire msg he must have sent a grant before
invariant critical(S1) & critical(S2) -> S1 = S2 # only one site in the critical section
invariant ~grant(T, S, S)
invariant ~grant_(S, S)
invariant grant(T, S, R) -> grant_(S, R)
invariant critical(S) & R ~= S -> grant_(R, S)
