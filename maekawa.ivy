#lang ivy1.7

type site
type time
type message = { request, grant, inquire, failed, yield, release }

module total_order(t) = {
    relation (X:t < Y:t)
    relation (X:t <= Y:t)
    individual zero : t
    axiom [antireflexivity] ~(X:t < X)
    axiom [antisymmetry] ~(X:t < Y & Y < X)
    axiom [transitivity] X:t < Y & Y < Z -> X < Z
    axiom [totallity] X:t < Y | Y < X | X = Y
    axiom [related] X:t <= Y <-> X < Y | X = Y
    axiom [nonnegativity] zero <= X:t
}

instantiate total_order(time)

# network messages
relation deliver(M:message, S:site, R:site, T:time)

relation request_queue(S:site, R:site, T:time)
relation received_grant(S:site, R:site, T:time)
relation given_grant(R:site, S:site, T:time)

# relation quorum(S:site, R:site)
# relation queue(T:time, S:site, R:site)
# relation request(T:time, S:site, R:site)
# relation grant(T:time, S:site, R:site)
# derived grant_(S:site, R:site) = exists T. grant(T, S, R)
# relation inquire(S:site, R:site)
# relation failed(S:site, R:site)
# relation yield(S:site, R:site)
# relation release(S:site, R:site)
# relation critical(S:site)

relation critical(S:site)

individual now : time

individual s1 : site
individual s2 : site
individual s3 : site

axiom s1 ~= s2 & s1 ~= s3 & s2 ~= s3

action changetime = {
    local n : time {
	assume now < n;
	now := n;
    }
}

after init {
    request(T, S, R) := false;
    grant(T, S, R) := false;
    inquire(S, R) := false;
    yield(S, R) := false;
    failed(S, R) := false;
    release(S, R) := false;
    critical(S) := false;
    now := zero;
}

action handle_request(ts:time, sender:site, receiver:site) = {
    require request(ts, sender, receiver);
    call changetime;
    request(ts, sender, receiver) := false; # consume request message
    if some t:time, k:site. grant(t, receiver, K) { # if 
	if t <= ts {
	    failed(receiver, sender) := true;
	} else {
	    inquire(receiver, sender) := true;
	};
	if ~exists T1:time. queue(T1, sender, receiver) { # add sender to queue iff not in queue already
	    queue(ts, sender, receiver) := true;
	};
    } else {
	grant(ts, receiver, sender) := true;
    };
}

action handle_inquire(sender:site, receiver:site) = {
    require inquire(sender, receiver);
    call changetime;
    inquire(sender, receiver) := false; # consume inquire message
    if some other:site. sender ~= other & failed(other, receiver) {
	yield(receiver, sender) := true;
	failed(other, receiver) := false;
    } else if some other:site. sender ~= other & yield(receiver, other) {
	if ~grant_(other, receiver) {
	    yield(receiver, sender) := true;
	};
    };
}

action handle_yield(sender:site, receiver:site) = {
    require yield(sender, receiver);
    yield(sender, receiver) := false; # consume yield message
    call changetime;
    if some t:time, s:site. queue(t, s, receiver) { # if the queue is not empty
	assume forall T0:time, S0:site. queue(T0, S0, receiver) -> t <= T0;
	queue(t, s, receiver) := false; # push the minimum out of the queue
	grant(t, receiver, s) := true; # give the minimum a grant
    };
    if some t:time. grant(t, receiver, sender) { # find the grant that was given and cancel and queue it
	grant(t, receiver, sender) := false;
	queue(T, sender, receiver) := true;
    } else {
#	assert false; ask oded
    };
}

action handle_release(sender:site, receiver:site) = {
    require release(sender, receiver);
    release(sender, receiver) := false; # consume release message
    call changetime;
    queue(T:time, sender, receiver) := false; # 
    if some t:time, s:site. queue(t, s, receiver) {
	assume queue(T0, S0, receiver) -> t <= T0; # t has top priority
	grant(t, receiver, s) := true;
    };
}

action enter_critical_section(s:site) = {
    require R ~= s -> grant_(R, s);
    critical(s) := true;
}

action exit_critical_section(s:site) = {
    require critical(s);
    critical(s) := false;
    release(s, X) := ~(s = X);
    grant(T, R, s) := false; # delete ALL grants to r
}

export handle_request
export handle_inquire
export handle_yield
export handle_release
export enter_critical_section
export exit_critical_section

invariant grant(T1, S, R1) & grant(T2, S, R2) -> T1 = T2 & R1 = R2  # every site can give only one grant
invariant grant_(S, R1) & grant_(S, R2) -> R1 = R2
invariant yield(K, J) -> inquire(J, K) # if someone sent a yield msg he must have recieved an inquire msg
invariant inquire(J, K) -> grant_(J, K) # if someone sent an inquire msg he must have sent a grant before
invariant critical(S1) & critical(S2) -> S1 = S2 # only one site in the critical section
invariant ~grant(T, S, S)
invariant ~grant_(S, S)
invariant grant(T, S, R) -> grant_(S, R)
invariant critical(S) & R ~= S -> grant_(R, S)
